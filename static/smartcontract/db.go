package smartcontract

import (
	"fmt"

	"github.com/blocklords/sds/common/blockchain"
	"github.com/blocklords/sds/common/smartcontract_key"
	"github.com/blocklords/sds/common/topic"
	"github.com/blocklords/sds/db"
)

// Whether the smartcontract address on network_id exist in database or not
func ExistInDatabase(db *db.Database, key smartcontract_key.Key) bool {
	fmt.Println("address ", key.Address, "network id", key.NetworkId)
	var exists bool
	err := db.Connection.QueryRow("SELECT IF(COUNT(address),'true','false') FROM static_smartcontract WHERE network_id = ? AND address = ?", key.NetworkId, key.Address).Scan(&exists)
	if err != nil {
		fmt.Println("Static Smartcontract exists returned db error: ", err.Error())
		return false
	}

	return exists
}

func SetInDatabase(db *db.Database, a *Smartcontract) error {
	result, err := db.Connection.Exec(`
		INSERT IGNORE INTO 
			static_smartcontract (
				network_id, 
				address, 
				abi_id, 
				transaction_id, 
				transaction_index,
				block_number, 
				block_timestamp, 
				deployer
			) 
		VALUES (?, ?, ?, ?, ?, ?, ?, ?) `,
		a.SmartcontractKey.NetworkId,
		a.SmartcontractKey.Address,
		a.AbiId,
		a.TransactionKey.Id,
		a.TransactionKey.Index,
		a.BlockHeader.Number,
		a.BlockHeader.Timestamp,
		a.Deployer,
	)
	if err != nil {
		return fmt.Errorf("db.Insert network id = %s, address = %s: %w", a.SmartcontractKey.NetworkId, a.SmartcontractKey.Address, err)
	}
	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("checking insert result: %w", err)
	}
	if affected != 1 {
		return fmt.Errorf("expected to have 1 affected rows. Got %d", affected)
	}

	return nil
}

// Returns the smartcontract by address on network_id from database
func GetFromDatabase(db *db.Database, key smartcontract_key.Key) (*Smartcontract, error) {
	query := `SELECT abi_id, transaction_id, transaction_index, block_number, block_timestamp, deployer FROM static_smartcontract WHERE network_id = ? AND address = ?`

	var s Smartcontract = Smartcontract{
		SmartcontractKey: key,
		TransactionKey:   blockchain.TransactionKey{},
		BlockHeader:      blockchain.BlockHeader{},
	}

	row := db.Connection.QueryRow(query, key.NetworkId, key.Address)
	if err := row.Scan(&s.AbiId, &s.TransactionKey.Id, &s.TransactionKey.Index, &s.BlockHeader.Number, &s.BlockHeader.Timestamp, &s.Deployer); err != nil {
		return nil, err
	}

	return &s, nil
}

// Returns the static smartcontracts by filter_query
// The filter_query is generated by categorizer/configuration from topic_filter
func FilterFromDatabase(con *db.Database, filter_query string, filter_parameters []string) ([]Smartcontract, []topic.Topic, error) {
	query := `SELECT s.network_id, s.address, s.abi_id, s.transaction_id, s.transaction_index, s.block_number, s.block_timestamp, s.deployer,
	static_configuration.organization, static_configuration.project, static_configuration.group_name, static_configuration.smartcontract_name
	FROM static_smartcontract AS s, static_configuration WHERE
	s.network_id = static_configuration.network_id AND s.address = static_configuration.smartcontract_address
	` + filter_query

	args := make([]interface{}, len(filter_parameters))
	for i, param := range filter_parameters {
		args[i] = param
	}

	rows, err := con.Connection.Query(query, args...)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	var smartcontracts []Smartcontract
	var topics []topic.Topic

	// Loop through rows, using Scan to assign column data to struct fields.
	for rows.Next() {
		var s Smartcontract = Smartcontract{
			SmartcontractKey: smartcontract_key.Key{},
			TransactionKey:   blockchain.TransactionKey{},
			BlockHeader:      blockchain.BlockHeader{},
		}

		var t topic.Topic
		if err := rows.Scan(&s.SmartcontractKey.NetworkId, &s.SmartcontractKey.Address, &s.AbiId, &s.TransactionKey.Id, &s.TransactionKey.Index, &s.BlockHeader.Number, &s.BlockHeader.Timestamp, &s.Deployer,
			&t.Organization, &t.Project, &t.Group, &t.Smartcontract); err != nil {
			return nil, nil, err
		}
		t.NetworkId = s.SmartcontractKey.NetworkId
		smartcontracts = append(smartcontracts, s)
		topics = append(topics, t)
	}
	return smartcontracts, topics, nil
}

func FilterKeysFromDatabase(con *db.Database, filter_query string, filter_parameters []string) ([]smartcontract_key.Key, []*topic.Topic, error) {
	query := `SELECT 
		static_smartcontract.network_id, 
		static_smartcontract.address, 
		static_configuration.organization, 
		static_configuration.project, 
		static_configuration.group_name, 
		static_configuration.smartcontract_name
	FROM 
		static_smartcontract, 
		static_configuration 
	WHERE
		static_smartcontract.network_id = static_configuration.network_id AND 
		static_smartcontract.address = static_configuration.address
	` + filter_query

	args := make([]interface{}, len(filter_parameters))
	for i, param := range filter_parameters {
		args[i] = param
	}

	rows, err := con.Connection.Query(query, args...)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	var smartcontracts []smartcontract_key.Key
	var topics []*topic.Topic

	// Loop through rows, using Scan to assign column data to struct fields.
	for rows.Next() {
		var key = smartcontract_key.Key{}
		var t topic.Topic

		if err := rows.Scan(&key.NetworkId, &key.Address, &t.Organization, &t.Project, &t.Group, &t.Smartcontract); err != nil {
			return nil, nil, err
		}
		t.NetworkId = key.NetworkId
		smartcontracts = append(smartcontracts, key)
		topics = append(topics, &t)
	}
	return smartcontracts, topics, nil
}
