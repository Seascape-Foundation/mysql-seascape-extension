package static

import (
	"encoding/json"

	"github.com/blocklords/gosds/message"
	"github.com/blocklords/gosds/remote"
	"github.com/blocklords/gosds/topic"
)

// The Configuration sets the relationship between the organization and the smartcontract.
type Configuration struct {
	Organization string
	Project      string
	NetworkId    string
	Group        string
	Name         string
	Address      string
	id           uint
	exists       bool
}

// Unique id of the configuration generated by the database
func (c *Configuration) SetId(id uint) {
	c.exists = true
	c.id = id
}

// The smartcontract address to which the configuration belongs too.
func (c *Configuration) SetAddress(address string) {
	c.Address = address
}

func (c *Configuration) Exists() bool { return c.exists }

// Creates a new static.Configuration class based on the given data
func NewConfiguration(parameters map[string]interface{}) (*Configuration, error) {
	organization, err := message.GetString(parameters, "o")
	if err != nil {
		return nil, err
	}
	project, err := message.GetString(parameters, "p")
	if err != nil {
		return nil, err
	}
	network_id, err := message.GetString(parameters, "n")
	if err != nil {
		return nil, err
	}
	group, err := message.GetString(parameters, "g")
	if err != nil {
		return nil, err
	}
	smartcontract_name, err := message.GetString(parameters, "s")
	if err != nil {
		return nil, err
	}

	conf := Configuration{
		Organization: organization,
		Project:      project,
		NetworkId:    network_id,
		Group:        group,
		Name:         smartcontract_name,
		exists:       true,
	}
	address, err := message.GetString(parameters, "address")
	if err == nil {
		conf.SetAddress(address)
	}
	id, err := message.GetUint64(parameters, "id")
	if err == nil {
		conf.SetId(uint(id))
	}

	return &conf, nil
}

// JSON representation of the static.Configuration
func (c *Configuration) ToJSON() map[string]interface{} {
	return map[string]interface{}{
		"s":       c.Name,
		"n":       c.NetworkId,
		"g":       c.Group,
		"o":       c.Organization,
		"p":       c.Project,
		"address": c.Address,
	}
}

// static.Configuration as a JSON string
func (c *Configuration) ToString() string {
	interfaces := c.ToJSON()
	byt, err := json.Marshal(interfaces)
	if err != nil {
		return ""
	}

	return string(byt)
}

// get configuration from SDS Static by the configuration topic
func RemoteConfiguration(socket *remote.Socket, t *topic.Topic) (*Configuration, *Smartcontract, error) {
	// Send hello.
	request := message.Request{
		Command: "configuration_get",
		Param:   t.ToJSON(),
	}
	params, err := socket.RequestRemoteService(&request)
	if err != nil {
		return nil, nil, err
	}

	returnedConfig := params["configuration"].(map[string]interface{})
	returnedSmartcontract := params["smartcontract"].(map[string]interface{})
	conf, err NewConfiguration(returnedConfig)
	if err != nil {
		return nil, nil, err
	}
	return conf, NewSmartcontract(returnedSmartcontract), nil
}

// Send a command to the SDS Static to register a new configuration
func RemoteConfigurationRegister(socket *remote.Socket, conf *Configuration) error {
	// Send hello.
	request := message.Request{
		Command: "configuration_register",
		Param:   conf.ToJSON(),
	}

	_, err := socket.RequestRemoteService(&request)
	return err
}
